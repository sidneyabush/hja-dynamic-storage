---
title: null
pagetitle: "HJA Dynamic Storage: MLR Updates"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: false
    theme: flatly
    highlight: textmate
    df_print: paged
params:
  out_dir: "/Users/sidneybush/Library/CloudStorage/Box-Box/05_Storage_Manuscript/final_workflow/outputs"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(dplyr)
library(readr)
library(knitr)

out_dir <- params$out_dir
box_out_dir <- "/Users/sidneybush/Library/CloudStorage/Box-Box/05_Storage_Manuscript/final_workflow/outputs"

# Always prefer Box outputs when available so reported paths match manuscript outputs.
if (dir.exists(box_out_dir)) {
  out_dir <- box_out_dir
} else if (!dir.exists(out_dir)) {
  stop(paste0("Output directory not found: ", out_dir))
}

path <- function(...) file.path(out_dir, ...)
fig <- function(...) file.path(out_dir, "figs", ...)
```

```{css, echo=FALSE}
body {
  font-size: 18px;
  line-height: 1.55;
}
h1, h2, h3 {
  font-weight: 500;
  margin-top: 1.2em;
}
h2 {
  border-bottom: 2px solid #d9dde3;
  padding-bottom: 0.25em;
}
table {
  font-size: 16px;
}
.caption {
  font-size: 15px;
  color: #4f5b66;
}
.main-container {
  max-width: 1200px;
}
#TOC ul,
#TOC ul ul,
#TOC ul ul ul {
  padding-left: 0 !important;
  margin-left: 0 !important;
}
#TOC li {
  margin-left: 0 !important;
  text-indent: 0 !important;
}
```

# HJA Dynamic Storage: MLR Updates

## MLR Structure

- Model set 1: watershed characteristics predict storage metrics
  - Selection stepwise AICc + constrained correlated pairs + iterative VIF filtering (VIF <= 10)
  - AICc tie-break for constrained correlated pairs
    - If Ash_Per and lava terms are both retained, test each drop option and keep the model with lowest AICc
    - If Landslide_Total and Landslide_Young are both retained, test both drop options and keep the model with lowest AICc

- Model set 2: storage metrics predict ecological variables
  - Selection constrained predictor sets, then stepwise AICc + iterative VIF filtering (VIF <= 10)
  - Correlated-predictor exclusions are enforced in model fitting; PCA screening is not used
  - Reported coefficients and fit metrics come from the single best model by AICc for each response

## Using Watershed Characteristics to Predict Storage Metrics

- Coefficients shown for this model set are model-averaged across all candidate models with delta AICc <= 2
  - This is used to stabilize inference given low site count and multiple correlated predictors
  - Correlated-pair conflicts are resolved with AICc tie-break before final model averaging
  - r2_adj_best_model below is from the single lowest-AICc model
  - r2_adj_weighted_aicc_lte2 below is Akaike-weighted across all models with delta AICc <= 2
  - Weighting uses weight = exp(-0.5 * delta_AICc) normalized to sum to 1

- Candidate predictor pool for this model set
  - basin_slope
  - Harvest
  - Landslide_Total
  - Landslide_Young
  - Lava1_per
  - Lava2_per
  - Ash_Per
  - Pyro_per


```{r catch-summary}
mlr1_strict <- read_csv(path("models", "watershed_char_storage_mlr", "watershed_char_storage_mlr_summary_strict.csv"), show_col_types = FALSE)
if (!("low_n_flag" %in% names(mlr1_strict))) mlr1_strict$low_n_flag <- NA
mlr1_selected <- mlr1_strict %>%
  mutate(Outcome = ifelse(Outcome == "DR", "DR_mean", Outcome)) %>%
  transmute(
    response = Outcome,
    n = N,
    predictors_final = Predictors_Final,
    r2_adj_best_model = round(R2_adj, 3),
    r2_adj_weighted_aicc_lte2 = round(R2_adj_weighted_AICc_LTE2, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3),
    low_n = low_n_flag
  ) %>%
  arrange(desc(r2_adj_best_model))

kable(mlr1_selected)
```

```{r catch-selection-screening, include=FALSE}
catch_predictor_pool <- c(
  "basin_slope", "Harvest", "Landslide_Total", "Landslide_Young",
  "Lava1_per", "Lava2_per", "Ash_Per", "Pyro_per"
)

catch_best <- mlr1_strict %>%
  mutate(response = ifelse(Outcome == "DR", "DR_mean", Outcome)) %>%
  transmute(response, predictors_final = Predictors_Final)

catch_screen <- catch_best %>%
  rowwise() %>%
  mutate(pred_list = list(strsplit(gsub("\\s+", "", predictors_final), ";")[[1]])) %>%
  ungroup() %>%
  tidyr::uncount(length(catch_predictor_pool), .id = "pred_idx") %>%
  mutate(
    predictor = catch_predictor_pool[pred_idx],
    selection_decision = ifelse(predictor %in% pred_list, "retained", "dropped"),
    why_dropped = ifelse(selection_decision == "dropped", "not retained in best AICc model", NA_character_)
  ) %>%
  select(response, predictor, selection_decision, why_dropped) %>%
  arrange(response, desc(selection_decision), predictor)

```

```{r catch-predictor-frequency}
catch_coef <- read_csv(path("models", "watershed_char_storage_mlr", "watershed_char_storage_mlr_results_strict.csv"), show_col_types = FALSE)
catch_predictor_freq <- catch_coef %>%
  mutate(Outcome = ifelse(Outcome == "DR", "DR_mean", Outcome)) %>%
  group_by(Predictor) %>%
  summarise(
    n_responses_retained = n_distinct(Outcome),
    mean_abs_beta = round(mean(abs(Beta_Std), na.rm = TRUE), 3),
    .groups = "drop"
  ) %>%
  arrange(desc(n_responses_retained), desc(mean_abs_beta))

kable(catch_predictor_freq, caption = "Watershed-characteristics predictors retained across storage responses.")
```

```{r catch-model-avg}
catch_avg_file <- path("models", "watershed_char_storage_mlr", "watershed_char_storage_mlr_model_avg_coef.csv")
if (file.exists(catch_avg_file)) {
  kable(tibble(file = catch_avg_file), caption = "Watershed model-averaged coefficient file path.")
} else {
  kable(tibble(note = "Run `02_stats/watershed_char_storage_mlr.R` to generate watershed_char_storage_mlr_model_avg_coef.csv"))
}
```

```{r catch-beta-fig, out.width='75%'}
knitr::include_graphics(fig("main", "watershed_char_storage_mlr_beta.png"))
```

## Using Storage Metrics to Predict Ecological Variables

- Ecological variables modeled
  - T_7DMax: annual maximum 7-day moving-average stream temperature
  - Q_7Q5: 7-day moving-average low-flow statistic (Q5) for discharge
  - T_Q7Q5: mean stream temperature during the annual Q5 7-day low-flow window

- Candidate predictor pool for this model set
  - RCS
  - RBI
  - FDC
  - SD
  - WB
  - CHS

- Predictor inclusion is controlled by complete-case sample size at model fit stage
- Ecological MLR results below are from the single best model by AICc for each response
- Ecological MLR does not use coefficient model averaging

```{r eco-summary}
mlr2_strict <- read_csv(path("models", "storage_ecovar_mlr", "storage_ecovar_mlr_summary_strict.csv"), show_col_types = FALSE)
if (!("low_n_flag" %in% names(mlr2_strict))) mlr2_strict$low_n_flag <- NA
site_levels <- c("WS09", "WS10", "WS01", "Look", "WS02", "WS03", "Mack", "WS06", "WS07", "WS08")

mlr2_selected <- mlr2_strict %>%
  transmute(
    site = factor(Site, levels = site_levels),
    response = Response,
    n = n,
    predictors_final = Predictors_Final,
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3),
    low_n = low_n_flag
  ) %>%
  arrange(site, desc(r2_adj), response)

hr <- "<hr style='border:0;border-top:2px solid #9aa4af;margin:0;'>"
eco_groups <- split(mlr2_selected, mlr2_selected$site, drop = TRUE)
eco_with_sep <- dplyr::bind_rows(lapply(seq_along(eco_groups), function(i) {
  block <- eco_groups[[i]] %>% mutate(across(everything(), as.character))
  if (i < length(eco_groups)) {
    sep <- as_tibble(as.data.frame(matrix(hr, nrow = 1, ncol = ncol(block)), stringsAsFactors = FALSE))
    names(sep) <- names(block)
    dplyr::bind_rows(block, sep)
  } else {
    block
  }
}))

kable(
  eco_with_sep,
  caption = "Eco-model best AICc results by site (ordered by adjusted R2, highest to lowest within site).",
  escape = FALSE
)
```


```{r eco-beta-fig, out.width='75%'}
knitr::include_graphics(fig("main", "storage_ecovar_mlr_beta.png"))
```

AICc < 2 candidate models (storage to ecological variables)

```{r eco-candidates-delta2}
eco_candidates_file <- path("models", "storage_ecovar_mlr", "storage_ecovar_mlr_model_selection.csv")
eco_out_file <- path("tables", "mlr", "storage_ecovar_mlr_aicc_lt2.csv")

if (file.exists(eco_candidates_file)) {
  eco_candidates <- read_csv(eco_candidates_file, show_col_types = FALSE)

  eco_candidates_top <- eco_candidates %>%
    group_by(Site, Response) %>%
    mutate(delta_aicc = AICc - min(AICc, na.rm = TRUE)) %>%
    ungroup() %>%
    filter(delta_aicc <= 2) %>%
    mutate(
      site = Site,
      site = factor(site, levels = c("WS09", "WS10", "WS01", "Look", "WS02", "WS03", "Mack", "WS06", "WS07", "WS08"))
    ) %>%
    transmute(
      site,
      response = Response,
      candidate_set = Candidate_Set,
      predictors_final = Predictors_Final,
      n = n,
      r2_adj = round(R2_adj, 3),
      rmse = signif(RMSE, 4),
      rmse_loocv = signif(RMSE_LOOCV, 4),
      aicc = round(AICc, 3),
      delta_aicc = round(delta_aicc, 3)
    ) %>%
    arrange(response, site, delta_aicc, desc(r2_adj))

  out_dir_tbl <- dirname(eco_out_file)
  if (!dir.exists(out_dir_tbl)) {
    dir.create(out_dir_tbl, recursive = TRUE, showWarnings = FALSE)
  }
  tryCatch(
    write_csv(eco_candidates_top, eco_out_file),
    error = function(e) NULL
  )
  kable(tibble(file = eco_out_file), caption = "AICc < 2 eco-candidate table output path.")
} else {
  kable(tibble(note = "Run `02_stats/storage_ecovar_mlr.R` to generate storage_ecovar_mlr_model_selection.csv"))
}
```

## Model screening

### Watershed model

```{r model-screening-watershed}
hr <- "<hr style='border:0;border-top:2px solid #9aa4af;margin:0;'>"
catch_groups <- split(catch_screen, catch_screen$response)
catch_with_sep <- dplyr::bind_rows(lapply(seq_along(catch_groups), function(i) {
  block <- catch_groups[[i]]
  if (i < length(catch_groups)) {
    sep <- as_tibble(as.data.frame(matrix(hr, nrow = 1, ncol = ncol(block)), stringsAsFactors = FALSE))
    names(sep) <- names(block)
    dplyr::bind_rows(block, sep)
  } else {
    block
  }
}))

kable(
  catch_with_sep,
  caption = "Watershed-characteristics predictors retained across storage responses.",
  escape = FALSE
)
```

### Eco model

Eco-model screening now uses constrained predictor sets, stepwise AICc, VIF checks, and correlated-predictor exclusions; PCA screening is not used.

## LOOCV Validation

```{r loocv-validation}
catch_loocv <- read_csv(path("models", "validation", "watershed_char_storage_mlr_loocv_validation.csv"), show_col_types = FALSE)
eco_loocv <- read_csv(path("models", "validation", "storage_ecovar_mlr_loocv_validation.csv"), show_col_types = FALSE)

catch_loocv_tbl <- catch_loocv %>%
  transmute(
    model_family,
    outcome,
    n,
    rmse_model = signif(rmse_model, 4),
    rmse_loocv = signif(rmse_loocv, 4),
    rmse_loocv_mean_runs = signif(rmse_loocv_mean_runs, 4),
    delta_rmse = signif(delta_rmse_loocv_minus_model, 4),
    r2_model = round(r2_model, 3),
    r2_loocv = round(r2_loocv, 3)
  ) %>%
  arrange(outcome)

eco_loocv_tbl <- eco_loocv %>%
  transmute(
    model_family,
    site,
    response,
    n,
    rmse_model = signif(rmse_model, 4),
    rmse_loocv = signif(rmse_loocv, 4),
    rmse_loocv_mean_runs = signif(rmse_loocv_mean_runs, 4),
    delta_rmse = signif(delta_rmse_loocv_minus_model, 4),
    r2_model = round(r2_model, 3),
    r2_loocv = round(r2_loocv, 3)
  ) %>%
  arrange(response, site)

kable(catch_loocv_tbl, caption = "Watershed-characteristics MLR LOOCV diagnostics.")
kable(eco_loocv_tbl, caption = "Storage-to-eco MLR LOOCV diagnostics.")
```
