---
title: null
pagetitle: "HJA Dynamic Storage: MLR Updates"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: false
    theme: flatly
    highlight: textmate
    df_print: paged
params:
  out_dir: "/Users/sidneybush/Library/CloudStorage/Box-Box/05_Storage_Manuscript/final_workflow/outputs"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(dplyr)
library(readr)
library(knitr)

out_dir <- params$out_dir
box_out_dir <- "/Users/sidneybush/Library/CloudStorage/Box-Box/05_Storage_Manuscript/final_workflow/outputs"

# Always prefer Box outputs when available so reported paths match manuscript outputs.
if (dir.exists(box_out_dir)) {
  out_dir <- box_out_dir
} else if (!dir.exists(out_dir)) {
  stop(paste0("Output directory not found: ", out_dir))
}

path <- function(...) file.path(out_dir, ...)
fig <- function(...) file.path(out_dir, "figs", ...)

catchment_label_map <- c(
  "basin_slope" = "Basin Slope",
  "Harvest" = "Harvest",
  "Landslide_Total" = "Total Landslide",
  "Landslide_Young" = "Young Landslide",
  "Lava1_per" = "Lava 1 (%)",
  "Lava2_per" = "Lava 2 (%)",
  "Ash_Per" = "Ash (%)",
  "Pyro_per" = "Pyroclastic (%)"
)
label_catchment <- function(x) {
  x_chr <- as.character(x)
  out <- unname(catchment_label_map[x_chr])
  out[is.na(out)] <- x_chr[is.na(out)]
  out
}
label_catchment_list <- function(x, sep = ";") {
  x_chr <- as.character(x)
  vapply(
    x_chr,
    function(val) {
      if (is.na(val) || !nzchar(val)) return(val)
      parts <- trimws(strsplit(val, sep, fixed = TRUE)[[1]])
      parts <- parts[nzchar(parts)]
      if (length(parts) == 0) return(val)
      paste(label_catchment(parts), collapse = "; ")
    },
    FUN.VALUE = character(1)
  )
}
```

```{css, echo=FALSE}
body {
  font-size: 18px;
  line-height: 1.55;
}
h1, h2, h3 {
  font-weight: 500;
  margin-top: 1.2em;
}
h2 {
  border-bottom: 2px solid #d9dde3;
  padding-bottom: 0.25em;
}
table {
  font-size: 16px;
}
.caption {
  font-size: 15px;
  color: #4f5b66;
}
.main-container {
  max-width: 1200px;
}
#TOC ul,
#TOC ul ul,
#TOC ul ul ul {
  padding-left: 0 !important;
  margin-left: 0 !important;
}
#TOC li {
  margin-left: 0 !important;
  text-indent: 0 !important;
}
```

# HJA Dynamic Storage: MLR Updates

## MLR Structure

- Model set 1: watershed characteristics predict storage metrics
  - Selection stepwise AICc + constrained correlated pairs + iterative VIF filtering (VIF <= 10)
  - AICc tie-break for constrained correlated pairs
    - If Ash (%) and lava terms are both retained, test each drop option and keep the model with lowest AICc
    - If Total Landslide and Young Landslide are both retained, test both drop options and keep the model with lowest AICc

- Model set 2: storage metrics predict ecological variables
  - Selection constrained predictor sets, then stepwise AICc + iterative VIF filtering (VIF <= 10)
  - Correlated-predictor exclusions are enforced in model fitting; PCA screening is not used
  - Reported coefficients and fit metrics come from the single best model by AICc for each response

## Using Watershed Characteristics to Predict Storage Metrics

- Coefficients shown for this model set are from the single best (minimum AICc) model for each response
  - Correlated-pair conflicts are resolved with AICc tie-break before the final best-model selection
  - All fit metrics shown below are from the single lowest-AICc model

- Candidate predictor pool for this model set
  - Basin Slope
  - Harvest
  - Total Landslide
  - Young Landslide
  - Lava 1 (%)
  - Lava 2 (%)
  - Ash (%)
  - Pyroclastic (%)


```{r catch-summary}
mlr1_summary <- read_csv(path("models", "watershed_char_storage_mlr", "watershed_char_storage_mlr_summary.csv"), show_col_types = FALSE)
mlr1_selected <- mlr1_summary %>%
  mutate(Outcome = ifelse(Outcome == "DR", "DR_mean", Outcome)) %>%
  transmute(
    response = gsub("_", " ", Outcome),
    n = N,
    predictors_final = label_catchment_list(Predictors_Final),
    r2 = round(R2, 3),
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  ) %>%
  arrange(desc(r2_adj))

kable(mlr1_selected)
```

```{r catch-selection-screening, include=FALSE}
catch_predictor_pool <- c(
  "basin_slope", "Harvest", "Landslide_Total", "Landslide_Young",
  "Lava1_per", "Lava2_per", "Ash_Per", "Pyro_per"
)

catch_best <- mlr1_summary %>%
  mutate(response = ifelse(Outcome == "DR", "DR_mean", Outcome)) %>%
  transmute(response, predictors_final = Predictors_Final)

catch_screen <- catch_best %>%
  rowwise() %>%
  mutate(pred_list = list(label_catchment(strsplit(gsub("\\s+", "", predictors_final), ";")[[1]]))) %>%
  ungroup() %>%
  tidyr::uncount(length(catch_predictor_pool), .id = "pred_idx") %>%
  mutate(
    predictor = label_catchment(catch_predictor_pool[pred_idx]),
    selection_decision = ifelse(predictor %in% pred_list, "retained", "dropped"),
    why_dropped = ifelse(selection_decision == "dropped", "not retained in best AICc model", NA_character_)
  ) %>%
  select(response, predictor, selection_decision, why_dropped) %>%
  arrange(response, desc(selection_decision), predictor)

```

```{r catch-predictor-frequency}
catch_coef <- read_csv(path("models", "watershed_char_storage_mlr", "watershed_char_storage_mlr_results.csv"), show_col_types = FALSE)
catch_predictor_freq <- catch_coef %>%
  mutate(Outcome = ifelse(Outcome == "DR", "DR_mean", Outcome)) %>%
  group_by(Predictor) %>%
  summarise(
    n_responses_retained = n_distinct(Outcome),
    mean_abs_beta = round(mean(abs(Beta_Std), na.rm = TRUE), 3),
    .groups = "drop"
  ) %>%
  mutate(Predictor = label_catchment(Predictor)) %>%
  arrange(desc(n_responses_retained), desc(mean_abs_beta))

kable(catch_predictor_freq, caption = "Watershed-characteristics predictors retained across storage responses.")
```

```{r catch-best-coef}
catch_best_coef_file <- path("models", "watershed_char_storage_mlr", "watershed_char_storage_mlr_results.csv")
if (file.exists(catch_best_coef_file)) {
  kable(tibble(file = catch_best_coef_file), caption = "Watershed best-model coefficient file path.")
} else {
  kable(tibble(note = "Run `02_stats/mlr_catch_char.R` to generate watershed_char_storage_mlr_results.csv"))
}
```

```{r catch-beta-fig, out.width='75%', fig.cap='Watershed-characteristics standardized coefficients from the single best (minimum AICc) model for each storage response.'}
knitr::include_graphics(fig("main", "watershed_char_storage_mlr_beta.png"))
```

AICc < 2 candidate models (watershed characteristics to storage variables)

```{r catch-candidates-delta2}
catch_candidates_file <- path("models", "watershed_char_storage_mlr", "watershed_char_storage_mlr_model_selection.csv")
catch_out_file <- path("tables", "mlr", "watershed_char_storage_mlr_aicc_lt2.csv")

if (file.exists(catch_candidates_file)) {
  catch_candidates <- read_csv(catch_candidates_file, show_col_types = FALSE)

  if (!("delta_AICc" %in% names(catch_candidates))) {
    catch_candidates <- catch_candidates %>%
      group_by(Outcome) %>%
      mutate(delta_AICc = AICc - min(AICc, na.rm = TRUE)) %>%
      ungroup()
  }

  catch_candidates_top <- catch_candidates %>%
    mutate(Outcome = ifelse(Outcome == "DR", "DR_mean", Outcome)) %>%
    filter(delta_AICc <= 2) %>%
    transmute(
      response = gsub("_", " ", Outcome),
      candidate_set = Candidate_Set,
      predictors_final = label_catchment_list(Predictors_Final),
      n = N,
      r2 = round(R2, 3),
      r2_adj = round(R2_adj, 3),
      rmse = signif(RMSE, 4),
      rmse_loocv = signif(RMSE_LOOCV, 4),
      aicc = round(AICc, 3),
      delta_aicc = round(delta_AICc, 3)
    ) %>%
    arrange(response, delta_aicc, desc(r2_adj))

  out_dir_tbl <- dirname(catch_out_file)
  if (!dir.exists(out_dir_tbl)) {
    dir.create(out_dir_tbl, recursive = TRUE, showWarnings = FALSE)
  }
  tryCatch(
    write_csv(catch_candidates_top, catch_out_file),
    error = function(e) NULL
  )
  kable(tibble(file = catch_out_file), caption = "AICc < 2 watershed-candidate table output path.")
} else {
  kable(tibble(note = "Run `02_stats/mlr_catch_char.R` to generate watershed_char_storage_mlr_model_selection.csv"))
}
```

## Using Storage Metrics to Predict Ecological Variables

- Ecological variables modeled
  - Q_7Q5: 7-day moving-average low-flow statistic (Q5) for discharge
  - T_Q7Q5: mean stream temperature during the annual Q5 7-day low-flow window
  - T_7DMax: annual maximum 7-day moving-average stream temperature

- Candidate predictor pool for this model set
  - P_NovJan: Nov-Dec (previous year) + Jan (current year) precipitation sum from paired watershed met inputs
  - RCS
  - RBI
  - FDC
  - SD
  - WB
  - CHS

- Predictor inclusion is controlled by complete-case sample size at model fit stage
- Ecological MLR results below are from the single best model by AICc for each response
- Ecological MLR does not use coefficient model averaging

```{r eco-summary}
mlr2_summary <- read_csv(path("models", "storage_ecovar_mlr", "storage_ecovar_mlr_summary.csv"), show_col_types = FALSE)
site_levels <- c("WS09", "WS10", "WS01", "Look", "WS02", "WS03", "Mack", "WS06", "WS07", "WS08")

mlr2_selected <- mlr2_summary %>%
  transmute(
    site = factor(Site, levels = site_levels),
    response = gsub("_", " ", Response),
    n = n,
    predictors_final = gsub("_", " ", Predictors_Final),
    r2 = round(R2, 3),
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  ) %>%
  arrange(site, desc(r2_adj), response)

hr <- "<hr style='border:0;border-top:2px solid #9aa4af;margin:0;'>"
eco_groups <- split(mlr2_selected, mlr2_selected$site, drop = TRUE)
eco_with_sep <- dplyr::bind_rows(lapply(seq_along(eco_groups), function(i) {
  block <- eco_groups[[i]] %>% mutate(across(everything(), as.character))
  if (i < length(eco_groups)) {
    sep <- as_tibble(as.data.frame(matrix(hr, nrow = 1, ncol = ncol(block)), stringsAsFactors = FALSE))
    names(sep) <- names(block)
    dplyr::bind_rows(block, sep)
  } else {
    block
  }
}))

kable(
  eco_with_sep,
  caption = "Eco-model best AICc results by site (ordered by adjusted R2, highest to lowest within site).",
  escape = FALSE
)
```


```{r eco-beta-fig, out.width='75%'}
knitr::include_graphics(fig("main", "storage_ecovar_mlr_beta.png"))
```

```{r eco-r2-heatmap-fig, out.width='60%'}
knitr::include_graphics(fig("main", "storage_ecovar_mlr_r2_heatmap.png"))
```

AICc < 2 candidate models (storage to ecological variables)

```{r eco-candidates-delta2}
eco_candidates_file <- path("models", "storage_ecovar_mlr", "storage_ecovar_mlr_model_selection.csv")
eco_out_file <- path("tables", "mlr", "storage_ecovar_mlr_aicc_lt2.csv")

if (file.exists(eco_candidates_file)) {
  eco_candidates <- read_csv(eco_candidates_file, show_col_types = FALSE)

  eco_candidates_top <- eco_candidates %>%
    group_by(Site, Response) %>%
    mutate(delta_aicc = AICc - min(AICc, na.rm = TRUE)) %>%
    ungroup() %>%
    filter(delta_aicc <= 2) %>%
    mutate(
      site = Site,
      site = factor(site, levels = c("WS09", "WS10", "WS01", "Look", "WS02", "WS03", "Mack", "WS06", "WS07", "WS08"))
    ) %>%
    transmute(
      site,
      response = Response,
      candidate_set = Candidate_Set,
      predictors_final = Predictors_Final,
      n = n,
      r2 = round(R2, 3),
      r2_adj = round(R2_adj, 3),
      rmse = signif(RMSE, 4),
      rmse_loocv = signif(RMSE_LOOCV, 4),
      aicc = round(AICc, 3),
      delta_aicc = round(delta_aicc, 3)
    ) %>%
    arrange(response, site, delta_aicc, desc(r2_adj))

  out_dir_tbl <- dirname(eco_out_file)
  if (!dir.exists(out_dir_tbl)) {
    dir.create(out_dir_tbl, recursive = TRUE, showWarnings = FALSE)
  }
  tryCatch(
    write_csv(eco_candidates_top, eco_out_file),
    error = function(e) NULL
  )
  kable(tibble(file = eco_out_file), caption = "AICc < 2 eco-candidate table output path.")
} else {
  kable(tibble(note = "Run `02_stats/mlr_eco_vars.R` to generate storage_ecovar_mlr_model_selection.csv"))
}
```

## Model screening

### Watershed model

```{r model-screening-watershed}
hr <- "<hr style='border:0;border-top:2px solid #9aa4af;margin:0;'>"
catch_groups <- split(catch_screen, catch_screen$response)
catch_with_sep <- dplyr::bind_rows(lapply(seq_along(catch_groups), function(i) {
  block <- catch_groups[[i]]
  if (i < length(catch_groups)) {
    sep <- as_tibble(as.data.frame(matrix(hr, nrow = 1, ncol = ncol(block)), stringsAsFactors = FALSE))
    names(sep) <- names(block)
    dplyr::bind_rows(block, sep)
  } else {
    block
  }
}))

kable(
  catch_with_sep,
  caption = "Watershed-characteristics predictors retained in the single best (minimum AICc) model for each storage response.",
  escape = FALSE
)
```

### Eco model

Eco-model screening now uses constrained predictor sets, stepwise AICc, VIF checks, and correlated-predictor exclusions; PCA screening is not used.

## LOOCV Validation

```{r loocv-validation}
catch_loocv <- read_csv(path("models", "validation", "watershed_char_storage_mlr_loocv_validation.csv"), show_col_types = FALSE)
eco_loocv <- read_csv(path("models", "validation", "storage_ecovar_mlr_loocv_validation.csv"), show_col_types = FALSE)
if (!("r2_adj_model" %in% names(catch_loocv))) catch_loocv$r2_adj_model <- NA_real_
if (!("r2_adj_model" %in% names(eco_loocv))) eco_loocv$r2_adj_model <- NA_real_

catch_loocv_tbl <- catch_loocv %>%
  transmute(
    model_family,
    outcome,
    n,
    rmse_model = signif(rmse_model, 4),
    rmse_loocv = signif(rmse_loocv, 4),
    rmse_loocv_mean_runs = signif(rmse_loocv_mean_runs, 4),
    delta_rmse = signif(delta_rmse_loocv_minus_model, 4),
    r2_model = round(r2_model, 3),
    r2_adj_model = round(r2_adj_model, 3),
    r2_loocv = round(r2_loocv, 3)
  ) %>%
  arrange(outcome)

eco_loocv_tbl <- eco_loocv %>%
  transmute(
    model_family,
    site,
    response,
    n,
    rmse_model = signif(rmse_model, 4),
    rmse_loocv = signif(rmse_loocv, 4),
    rmse_loocv_mean_runs = signif(rmse_loocv_mean_runs, 4),
    delta_rmse = signif(delta_rmse_loocv_minus_model, 4),
    r2_model = round(r2_model, 3),
    r2_adj_model = round(r2_adj_model, 3),
    r2_loocv = round(r2_loocv, 3)
  ) %>%
  arrange(response, site)

kable(catch_loocv_tbl, caption = "Watershed-characteristics MLR LOOCV diagnostics.")
kable(eco_loocv_tbl, caption = "Storage-to-eco MLR LOOCV diagnostics.")
```
