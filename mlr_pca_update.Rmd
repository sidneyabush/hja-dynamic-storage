---
title: "MLR and PCA Results"
output:
  html_document:
    toc: true
    toc_depth: 2
    df_print: paged
params:
  out_dir: "/Users/sidneybush/Library/CloudStorage/Box-Box/05_Storage_Manuscript/05_Outputs/final_workflow"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(dplyr)
library(readr)
library(tidyr)
library(knitr)

out_dir <- params$out_dir
if (!dir.exists(out_dir)) {
  box_out_dir <- "/Users/sidneybush/Library/CloudStorage/Box-Box/05_Storage_Manuscript/05_Outputs/final_workflow"
  if (dir.exists(box_out_dir)) {
    out_dir <- box_out_dir
  } else {
    stop(paste0("Output directory not found: ", out_dir))
  }
}

path <- function(...) file.path(out_dir, ...)
fig <- function(...) file.path(out_dir, "figs", ...)
first_existing <- function(paths) {
  hit <- paths[file.exists(paths)]
  if (length(hit) == 0) stop("Missing expected file(s): ", paste(paths, collapse = " OR "))
  hit[[1]]
}
```

## PCA

```{r pca-summary}
pca_var <- read_csv(path("stats", "pca", "pca_variance_explained.csv"), show_col_types = FALSE)
pca_load <- read_csv(path("stats", "pca", "pca_loadings.csv"), show_col_types = FALSE)

pca_var <- pca_var %>%
  mutate(cum_var = cumsum(Variance_Explained))

kable(pca_var)

load_top <- pca_load %>%
  mutate(abs_pc1 = abs(PC1), abs_pc2 = abs(PC2)) %>%
  dplyr::select(feature, PC1, PC2, abs_pc1, abs_pc2) %>%
  arrange(desc(abs_pc1))

kable(load_top)
```

```{r pca-figs, out.width='48%', fig.show='hold'}
knitr::include_graphics(c(
  fig("main", "pca_biplot.png"),
  fig("supp", "stats", "pca", "pca_scree.png")
))
```

## How PCA informs the MLR models

PCA is used as a predictor-screening step before stepwise regression. Screening is done separately for each MLR analysis, with the full predictor pool for that analysis:

- MLR using watershed characteristics to predict storage metrics: PCA screening is run on watershed predictors.
- MLR using storage metrics to predict ecological variables: PCA screening is run on storage predictors, and screening is evaluated within each ecological response model candidate set.

Predictors are retained if they are significant on retained principal components, and collinear predictors are filtered so redundant variables are not carried forward into MLR.

```{r pca-screening-summary}
pca_screen_catch <- read_csv(
  first_existing(c(
    path("stats", "mlr_catch_chars_storage", "catch_chars_storage_mlr_pca_screening.csv"),
    path("stats", "mlr_catch_chars_storage", "catch_chars_storage_mlr_pca_screening_all_methods.csv")
  )),
  show_col_types = FALSE
)
pca_screen_eco <- read_csv(
  first_existing(c(
    path("stats", "mlr_storage_eco", "storage_eco_mlr_pca_screening.csv"),
    path("stats", "mlr_storage_eco", "storage_eco_mlr_pca_screening_all_methods.csv")
  )),
  show_col_types = FALSE
)

catch_screen_tbl <- pca_screen_catch %>%
  filter(Method == "strict") %>%
  group_by(Predictor) %>%
  summarise(
    retained_after_pca = any(retained_after_pca, na.rm = TRUE),
    drop_reason = paste(unique(na.omit(drop_reason)), collapse = "; "),
    .groups = "drop"
  ) %>%
  mutate(
    retained_after_pca = ifelse(retained_after_pca, "yes", "no"),
    drop_reason = ifelse(drop_reason == "", "", drop_reason)
  ) %>%
  arrange(desc(retained_after_pca), Predictor)

eco_screen_tbl <- pca_screen_eco %>%
  filter(Method == "strict") %>%
  group_by(Predictor) %>%
  summarise(
    retained_after_pca = any(retained_after_pca, na.rm = TRUE),
    drop_reason = paste(unique(na.omit(drop_reason)), collapse = "; "),
    .groups = "drop"
  ) %>%
  mutate(
    retained_after_pca = ifelse(retained_after_pca, "yes", "no"),
    drop_reason = ifelse(drop_reason == "", "", drop_reason)
  ) %>%
  arrange(desc(retained_after_pca), Predictor)

kable(catch_screen_tbl, caption = "PCA screening summary for watershed-characteristics predictors (strict workflow)")
kable(eco_screen_tbl, caption = "PCA screening summary for storage predictors in ecological models (strict workflow)")

eco_screen_by_response <- pca_screen_eco %>%
  filter(Method == "strict") %>%
  group_by(Response, Predictor) %>%
  summarise(
    retained_after_pca = any(retained_after_pca, na.rm = TRUE),
    drop_reason = paste(unique(na.omit(drop_reason)), collapse = "; "),
    .groups = "drop"
  ) %>%
  mutate(
    retained_after_pca = ifelse(retained_after_pca, "yes", "no"),
    drop_reason = ifelse(drop_reason == "", "", drop_reason)
  ) %>%
  arrange(Response, desc(retained_after_pca), Predictor)

kable(eco_screen_by_response, caption = "PCA screening by ecological response model (strict workflow)")
```

## MLR Method Comparison

```{r mlr-methods-table}
mlr_methods_tbl <- tibble(
  step = c(
    "predictor screening",
    "model selection",
    "multicollinearity filter",
    "coefficient standardization",
    "model validation"
  ),
  method = c(
    "PCA-based screening with retained PCs and collinearity filtering",
    "backward stepwise AIC (MASS::stepAIC) on centered/scaled predictors",
    "iterative VIF filtering until all retained predictors have VIF <= 10",
    "standardized beta coefficients",
    "LOOCV metrics (RMSE_LOOCV and R2_LOOCV)"
  )
)
kable(mlr_methods_tbl)
```

The workflow follows the Johnson et al. (2023) structure: centered and scaled predictors, backward stepwise AIC selection, iterative VIF filtering to a threshold of 10, and LOOCV diagnostics. In this report, "strict" means that iterative VIF filtering is always enforced and known high-correlation predictor pairs (Perry et al., 2025) are not allowed in the same final model.

Model structure used here:

- Model set 1: watershed characteristics predict storage metrics.
- Model set 2: storage metrics predict ecological variables.
- Within each model set, each response variable is modeled separately.

## MLR: using watershed characteristics to predict storage metrics

```{r mlr1-compare}
mlr1_strict <- read_csv(path("stats", "mlr_catch_chars_storage", "catch_chars_storage_mlr_summary_strict.csv"), show_col_types = FALSE)
mlr1_selected <- mlr1_strict %>%
  transmute(
    response = Outcome,
    n = N,
    predictors_final = Predictors_Final,
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  ) %>%
  arrange(desc(r2_adj))

kable(mlr1_selected)
```

Each storage metric is modeled separately as its own response. The final table above reports one selected model per storage metric.

```{r mlr1-beta-fig, out.width='75%'}
knitr::include_graphics(fig("supp", "stats", "mlr", "catch_chars_storage_mlr_beta.png"))
```

```{r mlr1-beta-interpret}
mlr1_beta_key <- mlr1_strict %>%
  transmute(
    response = Outcome,
    predictors_in_beta_plot = Predictors_Final,
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  ) %>%
  arrange(desc(r2_adj))

kable(mlr1_beta_key, caption = "How to read the beta plot (watershed characteristics to storage): only retained predictors are shown as tiles.")
```

### Candidate model comparison (`delta_AICc <= 2`) for watershed characteristics to storage

```{r catch-candidates-delta2}
catch_step_file <- path("stats", "mlr_catch_chars_storage", "catch_chars_storage_mlr_stepwise_path.csv")

if (file.exists(catch_step_file)) {
  catch_step <- read_csv(catch_step_file, show_col_types = FALSE)
  catch_n <- mlr1_strict %>% select(Outcome, N)

  catch_candidates <- catch_step %>%
    filter(Method == "strict") %>%
    left_join(catch_n, by = "Outcome") %>%
    mutate(
      k = N - Resid.Df,
      aicc = ifelse((N - k - 1) > 0, AIC + (2 * k * (k + 1)) / (N - k - 1), NA_real_)
    ) %>%
    group_by(Outcome) %>%
    mutate(delta_aicc = aicc - min(aicc, na.rm = TRUE)) %>%
    ungroup() %>%
    filter(delta_aicc <= 2) %>%
    transmute(
      response = Outcome,
      step = step,
      n = N,
      residual_df = Resid.Df,
      aic = round(AIC, 3),
      aicc = round(aicc, 3),
      delta_aicc = round(delta_aicc, 3)
    ) %>%
    arrange(response, delta_aicc, step)

  kable(catch_candidates)
} else {
  kable(tibble(note = "Run `02_stats/catchment_storage_mlr.R` to generate catch_chars_storage_mlr_stepwise_path.csv"))
}
```

## MLR: using storage metrics to predict ecological variables

Ecological variables modeled:
- `T_7DMax`
- `Q_7Q5`
- `T_Q7Q5`

```{r eco-shorthand-key}
eco_key <- tibble(
  shorthand = c("T_7DMax", "Q_7Q5", "T_Q7Q5"),
  meaning = c(
    "Annual maximum 7-day moving-average stream temperature",
    "7-day moving-average low-flow statistic (Q5) for discharge",
    "Mean stream temperature during the annual Q5 7-day low-flow window"
  )
)
kable(eco_key)
```

```{r mlr2-compare}
mlr2_strict <- read_csv(path("stats", "mlr_storage_eco", "storage_eco_mlr_summary_strict.csv"), show_col_types = FALSE)
mlr2_selected <- mlr2_strict %>%
  transmute(
    response = Response,
    n = n,
    predictors_final = Predictors_Final,
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  ) %>%
  arrange(desc(r2_adj))

kable(mlr2_selected)
```

Each ecological variable is modeled separately as its own response.

### Ecological model 1: `T_7DMax`

```{r eco-model-t7dmax}
eco_fit <- mlr2_strict %>%
  filter(Response == "T_7DMax") %>%
  transmute(
    response = Response,
    n = n,
    predictors_final = Predictors_Final,
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  )

eco_coef <- read_csv(path("stats", "mlr_storage_eco", "storage_eco_mlr_results_strict.csv"), show_col_types = FALSE) %>%
  filter(Response == "T_7DMax") %>%
  transmute(
    predictor = Predictor,
    beta_std = round(Beta_Std, 3),
    p_value = signif(p_value, 3),
    vif = round(VIF, 3)
  )

kable(eco_fit)
kable(eco_coef)
```

### Ecological model 2: `Q_7Q5`

```{r eco-model-q7q5}
eco_fit <- mlr2_strict %>%
  filter(Response == "Q_7Q5") %>%
  transmute(
    response = Response,
    n = n,
    predictors_final = Predictors_Final,
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  )

eco_coef <- read_csv(path("stats", "mlr_storage_eco", "storage_eco_mlr_results_strict.csv"), show_col_types = FALSE) %>%
  filter(Response == "Q_7Q5") %>%
  transmute(
    predictor = Predictor,
    beta_std = round(Beta_Std, 3),
    p_value = signif(p_value, 3),
    vif = round(VIF, 3)
  )

kable(eco_fit)
kable(eco_coef)
```

### Ecological model 3: `T_Q7Q5`

```{r eco-model-tq7q5}
eco_fit <- mlr2_strict %>%
  filter(Response == "T_Q7Q5") %>%
  transmute(
    response = Response,
    n = n,
    predictors_final = Predictors_Final,
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  )

eco_coef <- read_csv(path("stats", "mlr_storage_eco", "storage_eco_mlr_results_strict.csv"), show_col_types = FALSE) %>%
  filter(Response == "T_Q7Q5") %>%
  transmute(
    predictor = Predictor,
    beta_std = round(Beta_Std, 3),
    p_value = signif(p_value, 3),
    vif = round(VIF, 3)
  )

kable(eco_fit)
kable(eco_coef)
```

```{r mlr2-beta-fig, out.width='75%'}
knitr::include_graphics(fig("supp", "stats", "mlr", "storage_eco_mlr_beta.png"))
```

```{r mlr2-beta-interpret}
mlr2_beta_key <- mlr2_strict %>%
  transmute(
    response = Response,
    predictors_in_beta_plot = Predictors_Final,
    r2_adj = round(R2_adj, 3),
    rmse = signif(RMSE, 4),
    rmse_loocv = signif(RMSE_LOOCV, 4),
    aicc = round(AICc, 3)
  ) %>%
  arrange(desc(r2_adj))

kable(mlr2_beta_key, caption = "How to read the beta plot (storage to ecological variables): only retained predictors are shown as tiles.")
```

## Candidate model comparison (`delta_AICc <= 2`)

This table is provided for collaborator review so top-competing models can be compared, not only the selected best model.

```{r eco-candidates-delta2}
eco_candidates_file <- path("stats", "mlr_storage_eco", "storage_eco_mlr_model_selection.csv")

if (file.exists(eco_candidates_file)) {
  eco_candidates <- read_csv(eco_candidates_file, show_col_types = FALSE)

  eco_candidates_top <- eco_candidates %>%
    group_by(Response) %>%
    mutate(delta_aicc = AICc - min(AICc, na.rm = TRUE)) %>%
    ungroup() %>%
    filter(delta_aicc <= 2) %>%
    transmute(
      response = Response,
      candidate_set = Candidate_Set,
      predictors_final = Predictors_Final,
      n = n,
      r2_adj = round(R2_adj, 3),
      rmse = signif(RMSE, 4),
      rmse_loocv = signif(RMSE_LOOCV, 4),
      aicc = round(AICc, 3),
      delta_aicc = round(delta_aicc, 3)
    ) %>%
    arrange(response, delta_aicc, desc(r2_adj))

  kable(eco_candidates_top)
} else {
  kable(tibble(note = "Run `02_stats/predict_thermal_lowflow.R` to generate storage_eco_mlr_model_selection.csv"))
}
```

## Correlation Context

```{r corr-figs, out.width='48%', fig.show='hold'}
knitr::include_graphics(c(
  fig("supp", "stats", "correlations", "catch_chars_storage_mlr_corr.png"),
  fig("supp", "stats", "correlations", "storage_eco_mlr_corr.png")
))
```
